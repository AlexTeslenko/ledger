#include<iostream>

#include<math/linalg/matrix.hpp>
#include<random/lcg.hpp>
#include"unittest.hpp"
#include<iomanip>
using namespace fetch::math::linalg;

typedef float data_type;
typedef fetch::memory::SharedArray< data_type > container_type;
typedef Matrix<data_type,container_type>  matrix_type;
typedef typename matrix_type::vector_register_type vector_register_type;


Matrix<data_type, container_type> RandomMatrix(int n, int m) {
  static fetch::random::LinearCongruentialGenerator gen;
  Matrix<data_type,container_type> m1(n, m);
  for(std::size_t i=0; i < n; ++i)
    for(std::size_t j=0; j < m; ++j)
      m1(i,j) = gen.AsDouble();
  return m1;
}


void test_invert(std::size_t const &n) {
  static fetch::random::LinearCongruentialGenerator gen;
  Matrix<data_type, container_type> m1 = RandomMatrix(n, n);

  Matrix<data_type, container_type> m2 = m1.Copy();
  int errcode = m2.Invert();

  if( errcode != Matrix<data_type,container_type>::INVERSION_OK ) {
    std::cerr << "inversion singular" << std::endl;
    exit(-1);
  }
  //  m2.Transpose();
  
  Matrix<data_type,container_type> ret;
  m1.DotReference( m2, ret );
  for(std::size_t i=0; i < n; ++i) {
    for(std::size_t j=0; j < n; ++j) {
      if(i==j ) {
        if( fabs(ret(i,j) -1) > 1e-10) {
          std::cerr << "Expected 1 on the diagonal, but found " << ret(i,j) << std::endl;
          exit(-1);
        }
      } else if( fabs(ret(i,j)) > 1e-10) {
        std::cerr << "Off-diagonal is non-zero" << std::endl;
        exit(-1);
      }
    }

  }
}

 

template< typename D >
using _M = Matrix<D,fetch::memory::Array< D > >;

void Test1() {
  SCENARIO("Basic matrix operation") {
  SECTION("Addition for int") {

    _M<int> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<int>(R"(
90 6 56 53 ;
-69 41 -21 70 ;
1 -14 -28 13 ;
97 -72 -90 -9
)");
    B = _M<int>(R"(
81 -30 17 -70 ;
95 29 96 -90 ;
-25 -78 91 -88 ;
57 -76 58 -71
)");
    C = _M<int>(R"(
171 -24 73 -17 ;
26 70 75 -20 ;
-24 -92 63 -75 ;
154 -148 -32 -80
)");
        
    EXPECT( R.Add(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineAdd(B) ).AllClose(C) );
    EXPECT( (R = A, R += B).AllClose(C) );
    EXPECT( (A + B).AllClose(C) );
  };


  SECTION("Multiplication for int") {

    _M<int> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<int>(R"(
29 -3 7 -97 ;
-88 81 94 -67 ;
96 -64 72 34 ;
8 14 -36 39
)");
    B = _M<int>(R"(
-18 63 79 52 ;
-32 98 49 -75 ;
48 -10 26 -33 ;
75 -48 -96 69
)");
    C = _M<int>(R"(
-522 -189 553 -5044 ;
2816 7938 4606 5025 ;
4608 640 1872 -1122 ;
600 -672 3456 2691
)");
        
    EXPECT( R.Multiply(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineMultiply(B) ).AllClose(C) );
    EXPECT( (R = A, R *= B).AllClose(C) );
    EXPECT( (A * B).AllClose(C) );
  };


  SECTION("Subtraction for int") {

    _M<int> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<int>(R"(
-23 -63 -42 -43 ;
-43 88 -46 74 ;
13 -6 9 28 ;
-18 13 31 -58
)");
    B = _M<int>(R"(
-57 -34 -29 11 ;
14 78 94 -88 ;
-84 35 30 -8 ;
84 -27 -67 92
)");
    C = _M<int>(R"(
34 -29 -13 -54 ;
-57 10 -140 162 ;
97 -41 -21 36 ;
-102 40 98 -150
)");
        
    EXPECT( R.Subtract(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineSubtract(B) ).AllClose(C) );
    EXPECT( (R = A, R -= B).AllClose(C) );
    EXPECT( (A - B).AllClose(C) );
  };


  SECTION("Addition for float") {

    _M<float> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<float>(R"(
-0.046376309785 1.62118654723 1.25019966361 -0.285851798316 ;
0.751442726981 -0.309262290939 -0.558300551088 -1.60300681085 ;
0.542090511159 -0.103126048098 -0.158266330099 0.270170278429 ;
0.530627652554 1.47511781862 -0.520035737343 -2.23325101798
)");
    B = _M<float>(R"(
0.0170731827593 0.412663893393 -1.37060375672 -1.16180330942 ;
0.611542876519 -0.462732719494 1.72491231999 0.142446121054 ;
-0.133048648904 0.622989356926 0.585882588289 0.200966138529 ;
1.81014989246 1.73297390747 0.107428506914 -0.0350749165596
)");
    C = _M<float>(R"(
-0.0293031270257 2.03385044063 -0.120404093105 -1.44765510774 ;
1.3629856035 -0.771995010433 1.1666117689 -1.46056068979 ;
0.409041862255 0.519863308828 0.427616258191 0.471136416958 ;
2.34077754502 3.20809172609 -0.412607230429 -2.26832593454
)");
        
    EXPECT( R.Add(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineAdd(B) ).AllClose(C) );
    EXPECT( (R = A, R += B).AllClose(C) );
    EXPECT( (A + B).AllClose(C) );
  };


  SECTION("Multiplication for float") {

    _M<float> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<float>(R"(
-0.0663775662016 -1.50678293313 -0.254349048508 -3.10991440703 ;
0.392483708157 -0.40435091015 0.348498124855 -0.150465453464 ;
-0.479096943036 -0.0112628232035 -0.951465539615 0.0754644198736 ;
-0.382764395322 -0.220991420551 -0.895380309577 0.979829374992
)");
    B = _M<float>(R"(
-1.64671666995 -0.852302320149 0.229418033186 -0.574375911495 ;
0.991057309907 1.25485783114 -1.1983264186 0.516816812176 ;
0.0208197458564 -0.45248655581 2.17754521683 -0.901636121574 ;
-0.0283226178829 -0.571473245528 0.297399645203 1.11806088585
)");
    C = _M<float>(R"(
0.109305044775 1.28423458987 -0.0583522584514 1.78625992221 ;
0.388973847988 -0.507402906129 -0.417614509846 -0.0777630760018 ;
-0.00997467659457 0.00509627608003 -2.07185923477 -0.0680414468517 ;
0.0108408897079 0.126290684336 -0.26628578639 1.09550889899
)");
        
    EXPECT( R.Multiply(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineMultiply(B) ).AllClose(C) );
    EXPECT( (R = A, R *= B).AllClose(C) );
    EXPECT( (A * B).AllClose(C) );
  };


  SECTION("Subtraction for float") {

    _M<float> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<float>(R"(
-2.26123647772 -0.668493562686 1.55024242392 -0.377869855394 ;
-1.56153507749 -0.481764265729 -0.384366615423 0.249995762301 ;
0.551164773999 -0.620696207064 0.843788341914 0.579561835668 ;
0.688287964799 1.02164524696 0.496791632472 -0.728786852078
)");
    B = _M<float>(R"(
1.72865341925 -0.80113606261 -1.77218487648 -0.62764486993 ;
-1.79532993863 -1.3556644466 -0.14729626532 0.898924200952 ;
0.0225721185382 -0.0900252009324 0.936358698739 -0.524276889682 ;
1.24169916146 0.858532572681 -0.642149951616 -0.708539631673
)");
    C = _M<float>(R"(
-3.98988989697 0.132642499924 3.3224273004 0.249775014536 ;
0.23379486114 0.873900180873 -0.237070350103 -0.648928438651 ;
0.528592655461 -0.530671006131 -0.0925703568251 1.10383872535 ;
-0.553411196664 0.16311267428 1.13894158409 -0.0202472204054
)");
        
    EXPECT( R.Subtract(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineSubtract(B) ).AllClose(C) );
    EXPECT( (R = A, R -= B).AllClose(C) );
    EXPECT( (A - B).AllClose(C) );
  };


  SECTION("Division for float") {

    _M<float> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<float>(R"(
0.862127986211 -1.43935690923 -0.981957001889 0.0401874738752 ;
-0.946207209127 0.569969312689 -0.903964583382 -0.924670603274 ;
0.263567722351 0.1499094296 -1.45755953656 0.502247482123 ;
0.663476860713 0.671177508506 0.181360948235 -1.26828634145
)");
    B = _M<float>(R"(
0.313909636745 -0.357844744208 -0.918380369731 -0.695690732506 ;
0.487673208861 0.769138391966 0.653723167027 0.626786931189 ;
0.315432541309 -0.216146100726 -0.254932678299 -0.0669409150289 ;
0.314305521271 -0.38702407365 0.680403224623 0.0353867122733
)");
    C = _M<float>(R"(
2.74642089727 4.0222943959 1.06922690669 -0.057766291827 ;
-1.94024849414 0.741049099412 -1.38279416881 -1.47525507834 ;
0.835575560015 -0.693556021119 5.71742919067 -7.50284757695 ;
2.11092970315 -1.73420093013 0.266549219156 -35.8407509479
)");
        
    EXPECT( R.Divide(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineDivide(B) ).AllClose(C) );
    EXPECT( (R = A, R /= B).AllClose(C) );
    EXPECT( (A / B).AllClose(C) );
  };


  SECTION("Addition for double") {

    _M<double> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<double>(R"(
0.746594501021 0.461488589317 1.37888930434 1.39742303148 ;
-0.372802353186 0.302538378232 -1.68489609717 1.37543206727 ;
-2.52720994916 -0.516672550865 0.743640957613 -1.07624076206 ;
-0.0468550799596 -0.491556389768 0.181438071841 -0.279812126801
)");
    B = _M<double>(R"(
1.26509704709 1.25536059923 0.393929223993 0.936520416408 ;
-0.0802546016323 0.323806222567 -1.11164395309 -0.80933376747 ;
0.932642117563 0.298954478615 -0.168483373507 -0.494664132185 ;
1.06684840246 -1.14338193065 0.166899964325 -0.429628974648
)");
    C = _M<double>(R"(
2.01169154811 1.71684918855 1.77281852833 2.33394344789 ;
-0.453056954819 0.626344600798 -2.79654005026 0.566098299805 ;
-1.5945678316 -0.217718072251 0.575157584106 -1.57090489425 ;
1.0199933225 -1.63493832042 0.348338036166 -0.709441101448
)");
        
    EXPECT( R.Add(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineAdd(B) ).AllClose(C) );
    EXPECT( (R = A, R += B).AllClose(C) );
    EXPECT( (A + B).AllClose(C) );
  };


  SECTION("Multiplication for double") {

    _M<double> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<double>(R"(
3.02284466338 1.03037667202 0.0146179386638 0.443368539941 ;
-0.0943123468199 0.34628004955 -0.323798765931 -0.435702731928 ;
-0.791877559582 -1.68372008756 0.0632494919481 -0.33028733805 ;
0.0284781439288 0.214327933126 -0.275217694441 -0.496950496675
)");
    B = _M<double>(R"(
0.504455622528 -1.39230562038 1.23873436146 0.325724983383 ;
1.71698022065 0.127760493765 0.277708210698 0.21374092189 ;
3.96225942729 -0.447877327007 0.616134475167 -0.150106262357 ;
0.750241874382 -0.571028505398 -0.614561070457 1.32851989816
)");
    C = _M<double>(R"(
1.52489098647 -1.43459923155 0.0181077429166 0.144416210305 ;
-0.161932434053 0.0442409101113 -0.0899215759129 -0.0931275035923 ;
-3.13762432572 0.754100052243 0.038970192526 0.0495781978185 ;
0.0213654960801 -0.122387359318 0.169138080905 -0.660208623234
)");
        
    EXPECT( R.Multiply(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineMultiply(B) ).AllClose(C) );
    EXPECT( (R = A, R *= B).AllClose(C) );
    EXPECT( (A * B).AllClose(C) );
  };


  SECTION("Subtraction for double") {

    _M<double> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<double>(R"(
-2.06598262087 -0.729328841179 -1.03228859527 -1.61895817735 ;
-1.64704491999 -0.84011561977 0.0846261369049 -0.765081192049 ;
-1.83583207224 1.03203114682 0.0345509909123 0.033302239299 ;
1.31527887114 0.909909214237 -1.13044722437 2.10137141182
)");
    B = _M<double>(R"(
-0.634916059239 0.480190489079 1.10795184549 -1.71367874004 ;
0.694901163216 0.30797147008 -0.447948131167 -0.462215749591 ;
0.744446746426 -1.16163340189 -0.135317263023 0.516049149996 ;
1.11898747368 -0.938564169995 -0.0381320198209 0.162505612582
)");
    C = _M<double>(R"(
-1.43106656163 -1.20951933026 -2.14024044076 0.0947205626884 ;
-2.34194608321 -1.14808708985 0.532574268071 -0.302865442458 ;
-2.58027881866 2.19366454871 0.169868253935 -0.482746910697 ;
0.196291397453 1.84847338423 -1.09231520455 1.93886579924
)");
        
    EXPECT( R.Subtract(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineSubtract(B) ).AllClose(C) );
    EXPECT( (R = A, R -= B).AllClose(C) );
    EXPECT( (A - B).AllClose(C) );
  };


  SECTION("Division for double") {

    _M<double> A,B,C,R;
        
    R.Resize( 4, 4 );
    A = _M<double>(R"(
-1.19930884756 3.03469692228 -1.50282410631 0.847916629886 ;
-0.143773952057 1.31524854151 2.05093898957 -0.454450967957 ;
0.673639418238 0.308759615129 -0.505384640031 -1.54730789835 ;
1.06265535371 -1.00638501907 1.71227948536 -1.47623421081
)");
    B = _M<double>(R"(
0.179409747209 -0.265689044305 -0.947485604803 0.80580254298 ;
0.604424524614 1.29678742797 1.39738888986 0.0763802881353 ;
0.0141091414914 -0.959730175661 -0.739755594585 -1.60088698169 ;
-0.78941944628 -0.753028558465 -1.33367583979 0.430628102475
)");
    C = _M<double>(R"(
-6.68474743552 -11.4219874222 1.58611814121 1.05226353189 ;
-0.237869156862 1.01423603679 1.46769378549 -5.949846211 ;
47.7448906901 -0.321715022576 0.683177854591 0.966531626562 ;
-1.34612259518 1.3364500028 -1.28387981118 -3.42809538515
)");
        
    EXPECT( R.Divide(A,B).AllClose(C) );
    EXPECT( ( R = A, R.InlineDivide(B) ).AllClose(C) );
    EXPECT( (R = A, R /= B).AllClose(C) );
    EXPECT( (A / B).AllClose(C) );
  };

  };
}

int main() {
  static fetch::random::LinearCongruentialGenerator gen;
  Test1();

  return 0;
}
