<?xml version='1.0' encoding='utf-8'?>
<index xmlns="http://jessevdk.github.com/cldoc/1.0">
  <namespace name="details" ref="details#details">
    <namespace name="meta" ref="details::meta#details::meta">
      <structtemplate name="Log2" ref="details::meta::Log2#details::meta::Log2">
        <templatenontypeparameter id="details::meta::Log2::N" name="N">
          <type name="uint64_t" />
        </templatenontypeparameter>
      </structtemplate>
      <struct name="Log2" ref="details::meta::Log2#details::meta::Log2" />
    </namespace>
  </namespace>
  <namespace name="fetch" ref="fetch#fetch">
    <brief>TODO: Make variant stack as a circular buffer!</brief>
    <namespace name="assert" ref="fetch::assert#fetch::assert">
      <namespace name="details" ref="fetch::assert::details#fetch::assert::details">
        <struct name="Printer" ref="fetch::assert::details::Printer#fetch::assert::details::Printer" />
      </namespace>
    </namespace>
    <namespace name="byte_array" ref="fetch::byte_array#fetch::byte_array">
      <namespace name="consumers" ref="fetch::byte_array::consumers#fetch::byte_array::consumers" />
      <class name="ReferencedByteArray" ref="fetch::byte_array::ReferencedByteArray#fetch::byte_array::ReferencedByteArray" />
    </namespace>
    <namespace name="commandline" ref="fetch::commandline#fetch::commandline">
      <namespace name="VT100" ref="fetch::commandline::VT100#fetch::commandline::VT100">
        <namespace name="details" ref="fetch::commandline::VT100::details#fetch::commandline::VT100::details" />
      </namespace>
      <class name="ParamsParser" ref="fetch::commandline::ParamsParser#fetch::commandline::ParamsParser" />
    </namespace>
    <namespace name="crypto" ref="fetch::crypto#fetch::crypto">
      <class name="Prover" ref="fetch::crypto::Prover#fetch::crypto::Prover" />
      <class name="SHA256" ref="fetch::crypto::SHA256#fetch::crypto::SHA256" />
      <class name="StreamHasher" ref="fetch::crypto::StreamHasher#fetch::crypto::StreamHasher" />
    </namespace>
    <namespace name="math" ref="fetch::math#fetch::math">
      <classtemplate name="Exp" ref="fetch::math::Exp#fetch::math::Exp">
        <templatenontypeparameter id="fetch::math::Exp::N" name="N">
          <type name="uint8_t" />
        </templatenontypeparameter>
        <templatenontypeparameter id="fetch::math::Exp::C" name="C">
          <type name="uint64_t" />
        </templatenontypeparameter>
        <templatenontypeparameter id="fetch::math::Exp::O" name="O">
          <type builtin="yes" name="bool" />
        </templatenontypeparameter>
      </classtemplate>
    </namespace>
    <namespace name="memory" ref="fetch::memory#fetch::memory">
      <classtemplate name="Array" ref="fetch::memory::Array#fetch::memory::Array">
        <templatetypeparameter id="fetch::memory::Array::T" name="T" />
      </classtemplate>
      <classtemplate name="BackwardIterator" ref="fetch::memory::BackwardIterator#fetch::memory::BackwardIterator">
        <templatetypeparameter id="fetch::memory::BackwardIterator::T" name="T" />
      </classtemplate>
      <classtemplate name="ForwardIterator" ref="fetch::memory::ForwardIterator#fetch::memory::ForwardIterator">
        <templatetypeparameter id="fetch::memory::ForwardIterator::T" name="T" />
      </classtemplate>
      <classtemplate name="SharedArray" ref="fetch::memory::SharedArray#fetch::memory::SharedArray">
        <templatetypeparameter id="fetch::memory::SharedArray::T" name="T" />
      </classtemplate>
      <classtemplate name="SquareArray" ref="fetch::memory::SquareArray#fetch::memory::SquareArray">
        <templatetypeparameter id="fetch::memory::SquareArray::T" name="T" />
      </classtemplate>
    </namespace>
    <namespace name="mutex" ref="fetch::mutex#fetch::mutex">
      <class name="DebugMutex" ref="fetch::mutex::DebugMutex#fetch::mutex::DebugMutex" />
      <class name="ProductionMutex" ref="fetch::mutex::ProductionMutex#fetch::mutex::ProductionMutex" />
    </namespace>
    <namespace name="network" ref="fetch::network#fetch::network">
      <class name="AbstractClientConnection" ref="fetch::network::AbstractClientConnection#fetch::network::AbstractClientConnection" />
      <class name="AbstractNetworkServer" ref="fetch::network::AbstractNetworkServer#fetch::network::AbstractNetworkServer" />
      <class name="ClientConnection" ref="fetch::network::ClientConnection#fetch::network::ClientConnection" />
      <class name="ClientManager" ref="fetch::network::ClientManager#fetch::network::ClientManager" />
      <class name="NetworkClient" ref="fetch::network::NetworkClient#fetch::network::NetworkClient" />
      <class name="NetworkServer" ref="fetch::network::NetworkServer#fetch::network::NetworkServer">
        <struct name="Request" ref="fetch::network::NetworkServer::Request#fetch::network::NetworkServer::Request" />
      </class>
    </namespace>
    <namespace name="optimisation" ref="fetch::optimisation#fetch::optimisation">
      <classtemplate name="BruteForceOptimiser" ref="fetch::optimisation::BruteForceOptimiser#fetch::optimisation::BruteForceOptimiser">
        <templatetypeparameter id="fetch::optimisation::BruteForceOptimiser::T" name="T" />
      </classtemplate>
    </namespace>
    <namespace name="platform" ref="fetch::platform#fetch::platform" />
    <namespace name="random" ref="fetch::random#fetch::random">
      <classtemplate name="LaggedFibonacciGenerator" ref="fetch::random::LaggedFibonacciGenerator#fetch::random::LaggedFibonacciGenerator">
        <templatenontypeparameter id="fetch::random::LaggedFibonacciGenerator::P" name="P">
          <type name="size_t" />
        </templatenontypeparameter>
        <templatenontypeparameter id="fetch::random::LaggedFibonacciGenerator::Q" name="Q">
          <type name="size_t" />
        </templatenontypeparameter>
      </classtemplate>
      <class name="LinearCongruentialGenerator" ref="fetch::random::LinearCongruentialGenerator#fetch::random::LinearCongruentialGenerator" />
    </namespace>
    <namespace name="rpc" ref="fetch::rpc#fetch::rpc">
      <namespace name="details" ref="fetch::rpc::details#fetch::rpc::details">
        <structtemplate name="Packer" ref="fetch::rpc::details::Packer#fetch::rpc::details::Packer">
          <brief> Argument packing routines for callables.</brief>
          <templatetypeparameter id="fetch::rpc::details::Packer::T" name="T">
            <brief>is the type of the argument that will be packed next.</brief>
          </templatetypeparameter>
          <templatetypeparameter id="fetch::rpc::details::Packer::arguments" name="arguments">
            <brief>are the arguments that remains to be pack</brief>
          </templatetypeparameter>
        </structtemplate>
        <class name="PromiseImplementation" ref="fetch::rpc::details::PromiseImplementation#fetch::rpc::details::PromiseImplementation" />
      </namespace>
      <namespace name="error" ref="fetch::rpc::error#fetch::rpc::error" />
      <class name="AbstractCallable" ref="fetch::rpc::AbstractCallable#fetch::rpc::AbstractCallable">
        <brief> Abstract class for callables.</brief>
      </class>
      <class name="AbstractPublicationFeed" ref="fetch::rpc::AbstractPublicationFeed#fetch::rpc::AbstractPublicationFeed">
        <brief> Super class for publishers.</brief>
      </class>
      <classtemplate name="CallableClassMember" ref="fetch::rpc::CallableClassMember#fetch::rpc::CallableClassMember">
        <brief> A member function wrapper that takes a serialized input.</brief>
        <templatetypeparameter id="fetch::rpc::CallableClassMember::C" name="C">
          <brief>is the class type to which the member function belongs.</brief>
        </templatetypeparameter>
        <templatetypeparameter id="fetch::rpc::CallableClassMember::F" name="F">
          <brief>is the function signature.</brief>
        </templatetypeparameter>
      </classtemplate>
      <class name="FeedSubscriptionManager" ref="fetch::rpc::FeedSubscriptionManager#fetch::rpc::FeedSubscriptionManager">
        <brief> This is a subscription manager that is used on the server side.</brief>
      </class>
      <classtemplate name="Function" ref="fetch::rpc::Function#fetch::rpc::Function">
        <brief> A function wrapper that takes a serialized input.</brief>
        <templatetypeparameter id="fetch::rpc::Function::F" name="F">
          <brief>is the function signature.</brief>
        </templatetypeparameter>
      </classtemplate>
      <class name="Function" ref="fetch::rpc::Function#fetch::rpc::Function">
        <brief>No function args, void return</brief>
      </class>
      <class name="HasPublicationFeed" ref="fetch::rpc::HasPublicationFeed#fetch::rpc::HasPublicationFeed">
        <brief> Publication functionality for a single feed.</brief>
      </class>
      <class name="Promise" ref="fetch::rpc::Promise#fetch::rpc::Promise" />
      <class name="Protocol" ref="fetch::rpc::Protocol#fetch::rpc::Protocol">
        <brief> A class that defines a generic protocol.</brief>
      </class>
      <class name="ServiceClient" ref="fetch::rpc::ServiceClient#fetch::rpc::ServiceClient" />
      <class name="ServiceServer" ref="fetch::rpc::ServiceServer#fetch::rpc::ServiceServer">
        <struct name="PendingMessage" ref="fetch::rpc::ServiceServer::PendingMessage#fetch::rpc::ServiceServer::PendingMessage" />
      </class>
    </namespace>
    <namespace name="script" ref="fetch::script#fetch::script">
      <class name="AbstractSyntaxTree" ref="fetch::script::AbstractSyntaxTree#fetch::script::AbstractSyntaxTree" />
      <struct name="ASTGroupOperationType" ref="fetch::script::ASTGroupOperationType#fetch::script::ASTGroupOperationType" />
      <struct name="ASTNode" ref="fetch::script::ASTNode#fetch::script::ASTNode" />
      <struct name="ASTOperationType" ref="fetch::script::ASTOperationType#fetch::script::ASTOperationType" />
      <class name="Function" ref="fetch::script::Function#fetch::script::Function">
        <struct name="Operation" ref="fetch::script::Function::Operation#fetch::script::Function::Operation" />
      </class>
      <class name="Variant" ref="fetch::script::Variant#fetch::script::Variant">
        <brief>FIXME: replace asserts with throwing errors</brief>
      </class>
    </namespace>
    <namespace name="serializers" ref="fetch::serializers#fetch::serializers">
      <namespace name="error" ref="fetch::serializers::error#fetch::serializers::error" />
      <class name="Byte_ArrayBuffer" ref="fetch::serializers::Byte_ArrayBuffer#fetch::serializers::Byte_ArrayBuffer" />
      <class name="SerializableException" ref="fetch::serializers::SerializableException#fetch::serializers::SerializableException" />
      <class name="SizeCounter" ref="fetch::serializers::SizeCounter#fetch::serializers::SizeCounter" />
      <class name="TypedByte_ArrayBuffer" ref="fetch::serializers::TypedByte_ArrayBuffer#fetch::serializers::TypedByte_ArrayBuffer" />
      <structtemplate name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister">
        <templatetypeparameter id="fetch::serializers::TypeRegister::T" name="T" />
      </structtemplate>
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
      <struct name="TypeRegister" ref="fetch::serializers::TypeRegister#fetch::serializers::TypeRegister" />
    </namespace>
    <namespace name="storage" ref="fetch::storage#fetch::storage">
      <class name="FileObject" ref="fetch::storage::FileObject#fetch::storage::FileObject">
        <struct name="BlockType" ref="fetch::storage::FileObject::BlockType#fetch::storage::FileObject::BlockType" />
      </class>
      <classtemplate name="IndexedDocumentStore" ref="fetch::storage::IndexedDocumentStore#fetch::storage::IndexedDocumentStore">
        <templatetypeparameter id="fetch::storage::IndexedDocumentStore::B" name="B" />
      </classtemplate>
      <classtemplate name="RandomAccessStack" ref="fetch::storage::RandomAccessStack#fetch::storage::RandomAccessStack">
        <templatetypeparameter id="fetch::storage::RandomAccessStack::T" name="T" />
        <templatetypeparameter id="fetch::storage::RandomAccessStack::D" name="D">
          <default>
            <type name="uint64_t" />
          </default>
        </templatetypeparameter>
      </classtemplate>
      <class name="VariantStack" ref="fetch::storage::VariantStack#fetch::storage::VariantStack">
        <struct name="Header" ref="fetch::storage::VariantStack::Header#fetch::storage::VariantStack::Header" />
        <struct name="Separator" ref="fetch::storage::VariantStack::Separator#fetch::storage::VariantStack::Separator" />
      </class>
      <classtemplate name="VersionedRandomAccessStack" ref="fetch::storage::VersionedRandomAccessStack#fetch::storage::VersionedRandomAccessStack">
        <templatetypeparameter id="fetch::storage::VersionedRandomAccessStack::T" name="T" />
        <templatetypeparameter id="fetch::storage::VersionedRandomAccessStack::B" name="B">
          <default>
            <type name="uint64_t" />
          </default>
        </templatetypeparameter>
      </classtemplate>
    </namespace>
    <namespace name="string" ref="fetch::string#fetch::string" />
    <namespace name="unittest" ref="fetch::unittest#fetch::unittest">
      <namespace name="details" ref="fetch::unittest::details#fetch::unittest::details" />
      <class name="Expression" ref="fetch::unittest::Expression#fetch::unittest::Expression" />
      <class name="ExpressionStart" ref="fetch::unittest::ExpressionStart#fetch::unittest::ExpressionStart" />
      <class name="ProgramInserter" ref="fetch::unittest::ProgramInserter#fetch::unittest::ProgramInserter" />
      <class name="TestContext" ref="fetch::unittest::TestContext#fetch::unittest::TestContext" />
    </namespace>
    <namespace name="vectorize" ref="fetch::vectorize#fetch::vectorize">
      <structtemplate name="RegisterInfo" ref="fetch::vectorize::RegisterInfo#fetch::vectorize::RegisterInfo">
        <templatenontypeparameter id="fetch::vectorize::RegisterInfo::I" name="I">
          <type name="uint16_t" />
        </templatenontypeparameter>
        <templatetypeparameter id="fetch::vectorize::RegisterInfo::T" name="T" />
      </structtemplate>
      <classtemplate name="VectorMemory" ref="fetch::vectorize::VectorMemory#fetch::vectorize::VectorMemory">
        <templatetypeparameter id="fetch::vectorize::VectorMemory::T" name="T" />
        <templatenontypeparameter default="InstructionSet::" id="fetch::vectorize::VectorMemory::I" name="I">
          <type name="fetch::vectorize::InstructionSet" ref="fetch::vectorize#fetch::vectorize::InstructionSet" />
        </templatenontypeparameter>
        <templatenontypeparameter id="fetch::vectorize::VectorMemory::L" name="L">
          <type name="size_t" />
        </templatenontypeparameter>
      </classtemplate>
      <classtemplate name="VectorMemoryProxy" ref="fetch::vectorize::VectorMemoryProxy#fetch::vectorize::VectorMemoryProxy">
        <templatetypeparameter id="fetch::vectorize::VectorMemoryProxy::T" name="T" />
        <templatenontypeparameter id="fetch::vectorize::VectorMemoryProxy::L" name="L">
          <type name="size_t" />
        </templatenontypeparameter>
        <templatenontypeparameter default="InstructionSet::" id="fetch::vectorize::VectorMemoryProxy::I" name="I">
          <type name="fetch::vectorize::InstructionSet" ref="fetch::vectorize#fetch::vectorize::InstructionSet" />
        </templatenontypeparameter>
      </classtemplate>
      <classtemplate name="VectorRegister" ref="fetch::vectorize::VectorRegister#fetch::vectorize::VectorRegister">
        <templatetypeparameter id="fetch::vectorize::VectorRegister::T" name="T" />
        <templatenontypeparameter id="fetch::vectorize::VectorRegister::L" name="L">
          <type name="size_t" />
        </templatenontypeparameter>
        <templatenontypeparameter default="InstructionSet::" id="fetch::vectorize::VectorRegister::I" name="I">
          <type name="fetch::vectorize::InstructionSet" ref="fetch::vectorize#fetch::vectorize::InstructionSet" />
        </templatenontypeparameter>
      </classtemplate>
    </namespace>
  </namespace>
  <report name="Documentation generator" ref="report" />
</index>
